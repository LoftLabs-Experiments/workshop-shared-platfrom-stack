{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udfd7\ufe0f About This Workshop","text":""},{"location":"#seamless-kubernetes-multi-tenancy-with-vcluster-a-shared-platform-stack","title":"\ud83d\ude80 Seamless Kubernetes Multi-Tenancy with vCluster &amp; a Shared Platform Stack","text":""},{"location":"#why-multi-tenancy","title":"Why Multi-Tenancy?","text":"<p>As organizations scale, managing multiple teams and workloads efficiently within a single Kubernetes cluster becomes a challenge. Multi-tenancy allows teams to share a cluster while maintaining isolation, reducing infrastructure costs, and improving security.  </p> <p>This workshop introduces vCluster, a powerful tool for implementing Kubernetes multi-tenancy using virtual clusters. You will learn how to create and manage vClusters while leveraging a shared platform stack, including cert-manager for seamless TLS management and Ingress controllers for secure application routing.  </p>"},{"location":"#what-you-will-learn","title":"\ud83d\udccc What You Will Learn","text":"<p>By the end of this workshop, you will be able to: \u2705 Set up vCluster inside a Kubernetes cluster. \u2705 Enable cert-manager integration for automated TLS certificate management. \u2705 Deploy applications inside vCluster while using host cluster resources. \u2705 Configure Ingress for external access and secure apps with HTTPS. \u2705 Use GitHub Pages to publish workshop materials for participants.  </p>"},{"location":"#workshop-prerequisites","title":"\ud83d\udee0\ufe0f Workshop Prerequisites","text":"<p>To follow along with this workshop, make sure you have: - A Kubernetes cluster (local or cloud-based). - <code>kubectl</code> installed and configured. - The latest version of <code>vcluster</code> CLI. - Installed <code>cert-manager</code> and <code>nginx</code> Ingress Controller. - Basic knowledge of Kubernetes concepts (Pods, Deployments, Services, Ingress).  </p> <p>If you are new to vCluster, don\u2019t worry! This workshop provides step-by-step instructions.</p>"},{"location":"#workshop-outline","title":"\ud83d\udcdc Workshop Outline","text":""},{"location":"#session-1-understanding-vcluster","title":"Session 1: Understanding vCluster","text":"<p>\ud83d\udd39 Introduction to Kubernetes multi-tenancy. \ud83d\udd39 How vCluster provides isolated environments within a cluster. \ud83d\udd39 Setting up a virtual cluster.  </p>"},{"location":"#session-2-deploying-applications-in-a-vcluster","title":"Session 2: Deploying Applications in a vCluster","text":"<p>\ud83d\udd39 Creating a vCluster with cert-manager integration. \ud83d\udd39 Deploying an application inside a virtual cluster. \ud83d\udd39 Configuring Ingress to expose the application.  </p>"},{"location":"#session-3-securing-multi-tenant-workloads","title":"Session 3: Securing Multi-Tenant Workloads","text":"<p>\ud83d\udd39 How cert-manager works for managing TLS certificates. \ud83d\udd39 Requesting and managing HTTPS certificates for vCluster workloads. \ud83d\udd39 Ensuring secure communication in multi-tenant Kubernetes environments.  </p>"},{"location":"#who-should-attend","title":"\ud83c\udf0d Who Should Attend?","text":"<p>This workshop is designed for: - DevOps engineers looking to optimize Kubernetes multi-tenancy. - Platform engineers managing Kubernetes clusters at scale. - Cloud-native enthusiasts exploring Kubernetes ecosystem tools. - Developers who want to deploy and manage workloads securely in Kubernetes.  </p>"},{"location":"#additional-resources","title":"\ud83d\udd17 Additional Resources","text":"<ul> <li>vCluster Documentation: https://www.vcluster.com/docs </li> <li>Loft Labs Website: https://loft.sh </li> <li>vCluster Slack Community: Join Here </li> </ul> <p>\ud83d\ude80 Get ready to deep dive into Kubernetes multi-tenancy with vCluster! \ud83d\ude80  </p>"},{"location":"workshop/","title":"Workshop Guide","text":""},{"location":"workshop/#1-prerequisites","title":"1. Prerequisites","text":"<p>Before we dive in, ensure you have the following:</p> <p>A Kubernetes cluster with admin access The latest version of the vCluster CLI(v0.23+) installed cert-manager installed in the host cluster Nginx ingress controlled installed in the host cluster Basic understanding of Kubernetes resources like Ingress and Services</p>"},{"location":"workshop/#tools-to-install","title":"Tools to Install:","text":"<p>Install vCluster CLI on a Linux system follow the below command. If on a different system, refer to the docs.  Command:</p> <pre><code>curl -LO https://github.com/loft-sh/vcluster/releases/latest/download/vcluster-linux-amd64\nchmod +x vcluster-linux-amd64\nsudo mv vcluster-linux-amd64 /usr/local/bin/vcluster\n</code></pre> <p>Install cert-manager on the host cluster: Command:</p> <pre><code>kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.16.2/cert-manager.yaml\n</code></pre> <p>Install nginx ingress controller on the host cluster: Command:</p> <pre><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.4/deploy/static/provider/cloud/deploy.yaml\n</code></pre>"},{"location":"workshop/#building-the-application","title":"Building the application","text":"<p>Before building the Go application with ko, initialize the Go module in your repository:</p> <p>Replace with your GitHub username and repository name</p> <pre><code>go mod init github.com/&lt;your-github-username&gt;/workshop-shared-platform-stack\ngo mod tidy\n</code></pre> <p>This sets up your Go module path correctly. To build and deploy your Go application seamlessly, we will use ko:</p> <p>Set your GitHub Container Registry repository (replace ): <pre><code>export KO_DOCKER_REPO=ghcr.io/&lt;your-github-username&gt;/workshop-app\nexport KO_DEFAULT_PLATFORM=linux/amd64\n</code></pre> <p>Build and push your image:</p> <pre><code>ko build ./app -t latest\n</code></pre> <p>Update your Kubernetes Deployment YAML with the generated image URL Your Go application is now containerized and pushed.</p>"},{"location":"workshop/#2-setting-up-vcluster","title":"2. Setting Up vCluster","text":"<p>We will configure a vCluster with cert-manager integration enabled. vCluster Configuration</p> <p>Create a vcluster.yaml file:</p> <pre><code>integrations:\n  certManager:\n    enabled: true\nsync:\n  toHost:\n    ingresses:\n      enabled: true\n</code></pre> <p>Enable vCluster Pro in order to use this feature: For simplicity, I am using my vcluster.cloud account and then creating the access key to login and enable pro features. In this way I don\u2019t have to run any agent on the current cluster. You can either run vcluster platform start or sign up on vCluster cloud and once you login, you should be able to go to access keys and create a short lived access key for the demo (Remember to delete the key post demo for security reasons)</p> <p> Command:</p> <pre><code>vcluster platform login https://saiyam.vcluster.cloud --access-key &lt;your-access-key&gt;\n</code></pre> <p>Output:</p> <p>Create the vCluster Run the following command to create the vCluster:</p> <p>Command:</p> <pre><code>vcluster create democert -f vcluster.yaml\n</code></pre> <p>Output:</p> <p>Once the vCluster is created, verify it is running:</p> <pre><code>vcluster list\n\n      NAME   |     NAMESPACE     | STATUS  | VERSION | CONNECTED |  AGE    \n  -----------+-------------------+---------+---------+-----------+---------\n    democert | vcluster-democert | Running | 0.22.1  | True      | 3h3m1s  \n</code></pre> <p>Export the vCluster kubeconfig:</p> <p>You need to make sure for the next steps to be done, you have switched the context to the virtual cluster.</p> <pre><code>kubectl config current-context\nvcluster_democert_vcluster-democert_do-nyc1-demo\n</code></pre>"},{"location":"workshop/#3-configuring-cert-manager-integration","title":"3. Configuring cert-manager Integration","text":"<p>Create an Issuer Create an Issuer in the virtual cluster that references cert-manager in the host cluster. With the cert-manager integration, the namespaced Issuers and Certificates are synced from the virtual cluster to the host cluster.</p> <p>Create a file issuer.yaml with below configuration:</p> <pre><code>apiVersion: cert-manager.io/v1\nkind: Issuer\nmetadata:\n  name: letsencrypt\n  namespace: default\nspec:\n  acme:\n    email: saiyam-test@gmail.com\n    server: https://acme-v02.api.letsencrypt.org/directory\n    privateKeySecretRef:\n      name: example-issuer-account-key\n    solvers:\n    - http01:\n        ingress:\n          ingressClassName: nginx\n</code></pre> <p>Apply the Issuer inside the virtual cluster:</p> <p>Command: </p> <pre><code>kubectl apply -f issuer.yaml\n</code></pre> <p>Output:</p> <pre><code>kubectl get issuer\nNAME                  READY   AGE\nletsencrypt-staging   True    3h34m\n</code></pre>"},{"location":"workshop/#4-deploying-an-application-with-ingress","title":"4. Deploying an Application with Ingress","text":"<p>Deploy a Sample NGINX Application Create a file <code>app.yaml</code>:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: workshop-app\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: workshop-app\n  template:\n    metadata:\n      labels:\n        app: workshop-app\n    spec:\n      containers:\n      - name: workshop-app\n        image: ghcr.io/&lt;YOUR-GITHUB-USERNAME&gt;/workshop-app:latest  # &lt;-- replace with your ko image\n        ports:\n        - containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: workshop-service\nspec:\n  selector:\n    app: workshop-app\n  ports:\n  - protocol: TCP\n    port: 80\n    targetPort: 8080\n\n</code></pre> <p>Apply the file: Apply this on the virtual cluster</p> <pre><code>kubectl apply -f app.yaml\n</code></pre> <p>Output:</p> <pre><code>kubectl get pod,svc      \nNAME                         READY   STATUS    RESTARTS   AGE\npod/nginx-7769f8f85b-pmt2n   1/1     Running   0          3h34m\nNAME                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE\nservice/kubernetes   ClusterIP   10.245.238.188   &lt;none&gt;        443/TCP   3h35m\nservice/nginx        ClusterIP   10.245.212.192   &lt;none&gt;        80/TCP    3h34m\n</code></pre>"},{"location":"workshop/#5-configure-ingress-and-tls","title":"5. Configure Ingress and TLS","text":"<p>Create an Ingress Create a file ingress.yaml:</p> <pre><code>apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: example-ingress\n  namespace: default\n  annotations:\n    kubernetes.io/ingress.class: nginx\nspec:\n  ingressClassName: nginx\n  tls:\n  - hosts:\n    - cert.&lt;YOUR-EXTERNAL-IP&gt;.nip.io\n    secretName: example-cert-tls\n  rules:\n  - host: cert.&lt;YOUR-EXTERNAL-IP&gt;.nip.io\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: nginx\n            port:\n              number: 80\n</code></pre> <p>In above yaml file, the IP is the external IP of the nginx ingress controller manager running inside the host cluster.</p> <p>Apply the file: Apply this inside the virtual cluster.</p> <p>Command:</p> <pre><code>kubectl apply -f ingress.yaml\n</code></pre> <p>Output:</p> <pre><code>kubectl get ing\nNAME              CLASS   HOSTS                       ADDRESS         PORTS     AGE\nexample-ingress   nginx   cert.24.199.67.197.nip.io   24.199.67.197   80, 443   3h36m\n</code></pre>"},{"location":"workshop/#6-request-a-certificate","title":"6. Request a Certificate","text":"<p>Create a Certificate Resource Create a file certificate.yaml:</p> <pre><code>apiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\n  name: example-cert\n  namespace: default\nspec:\n  dnsNames:\n  - cert.&lt;YOUR-EXTERNAL-IP&gt;.nip.io\n  issuerRef:\n    name: letsencrypt\n    kind: Issuer\n  secretName: example-cert-tls\n</code></pre> <p>Apply the file: Apply this inside the virtual cluster.</p> <p>Command:</p> <pre><code>kubectl apply -f certificate.yaml\n</code></pre> <p>Output:</p> <pre><code>kubectl get certificate\nNAME           READY   SECRET             AGE\nexample-cert   True    example-cert-tls   3h36m\n</code></pre>"},{"location":"workshop/#7-testing-the-setup","title":"7. Testing the Setup","text":"<p>Verify that the https curl command is working as expected</p> <p>Command:</p> <pre><code>curl https://cert.24.199.67.197.nip.io\n</code></pre> <p>Output:</p> <pre><code>curl https://cert.24.199.67.197.nip.io\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\nhtml { color-scheme: light dark; }\nbody { width: 35em; margin: 0 auto;\nfont-family: Tahoma, Verdana, Arial, sans-serif; }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"}]}